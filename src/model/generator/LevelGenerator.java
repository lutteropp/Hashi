package model.generator;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

import model.base.Direction;
import model.base.GridNode;

/**
 * Generates a Hashiwokakero level.
 * 
 * @author Sarah Lutteropp
 *
 */
public class LevelGenerator {

	/**
	 * Generate a fixed level with width=15 and height=5. It is the level from
	 * https://www.it-talents.de/foerderung/code-competition/code-competition-12-2017
	 * 
	 * @return A fixed level with width=15, height=5 and 20 nodes.
	 */
	public static ArrayList<GridNode> getFixedLevelWidth15Height5() {
		ArrayList<GridNode> nodes = new ArrayList<GridNode>();
		nodes.add(new GridNode(0, 0, 2));
		nodes.add(new GridNode(2, 0, 3));
		nodes.add(new GridNode(5, 0, 3));
		nodes.add(new GridNode(12, 0, 6));
		nodes.add(new GridNode(14, 0, 3));
		nodes.add(new GridNode(1, 1, 2));
		nodes.add(new GridNode(9, 1, 4));
		nodes.add(new GridNode(11, 1, 3));
		nodes.add(new GridNode(6, 2, 2));
		nodes.add(new GridNode(2, 2, 3));
		nodes.add(new GridNode(12, 2, 2));
		nodes.add(new GridNode(1, 3, 3));
		nodes.add(new GridNode(5, 3, 3));
		nodes.add(new GridNode(7, 3, 3));
		nodes.add(new GridNode(9, 3, 3));
		nodes.add(new GridNode(0, 4, 1));
		nodes.add(new GridNode(2, 4, 1));
		nodes.add(new GridNode(11, 4, 4));
		nodes.add(new GridNode(14, 4, 3));
		return nodes;
	}

	/**
	 * A struct for encapsulating the return value of the nextDirection method.
	 * 
	 * @author Sarah Lutteropp
	 */
	private static final class DirectionSelection {
		/**
		 * The chosen direction.
		 */
		Direction dir;
		/**
		 * The node to be extended.
		 */
		IncompleteNode node;
	}

	/**
	 * Randomly pick the next direction for extending the generated level, taking
	 * the current extension possibilities into account. Each extension is equally
	 * likely.
	 * 
	 * @param possibleExtensions
	 *            The possible extensions
	 * @return The randomly selected direction as well as the selected
	 *         IncompleteNode.
	 */
	private static DirectionSelection nextDirection(
			final HashMap<Direction, ArrayList<IncompleteNode>> possibleExtensions) {
		int sizeEast = possibleExtensions.get(Direction.EAST).size();
		int sizeWest = possibleExtensions.get(Direction.WEST).size();
		int sizeNorth = possibleExtensions.get(Direction.NORTH).size();
		int sizeSouth = possibleExtensions.get(Direction.SOUTH).size();
		int sizeTotal = sizeEast + sizeWest + sizeNorth + sizeSouth;
		if (sizeTotal == 0) {
			throw new RuntimeException("No directional extensions are possible anymore");
		}
		Random rand = new Random();
		int val = rand.nextInt(sizeTotal);
		DirectionSelection result = new DirectionSelection();
		if (val < sizeEast) {
			result.dir = Direction.EAST;
			result.node = possibleExtensions.get(Direction.EAST).get(val);
		} else if (val < sizeEast + sizeWest) {
			result.dir = Direction.WEST;
			result.node = possibleExtensions.get(Direction.WEST).get(val - sizeEast);
		} else if (val < sizeEast + sizeWest + sizeNorth) {
			result.dir = Direction.NORTH;
			result.node = possibleExtensions.get(Direction.NORTH).get(val - sizeEast - sizeWest);
		} else {
			result.dir = Direction.SOUTH;
			result.node = possibleExtensions.get(Direction.SOUTH).get(val - sizeEast - sizeWest - sizeNorth);
		}
		return result;
	}

	/**
	 * Check whether the closest possible cell for a neighbor on the grid is already
	 * inhabited by another node. If so, return the neighboring node. Else, return
	 * null.
	 * 
	 * @param node
	 *            The node The node where we want to check for its direct neighbor
	 * @param dir
	 *            The direction. Can be EAST, WEST, NORTH, or SOUTH.
	 * @param cells
	 *            The current grid cells
	 * @return The direct neighbor or {@value null}, if it does not exist.
	 */
	private static IncompleteNode getDirectNeighborAt(IncompleteNode node, Direction dir,
			final ArrayList<ArrayList<IncompleteNode>> cells) {
		int x = node.getX();
		int y = node.getY();
		if (dir == Direction.EAST) {
			x += 2;
		} else if (dir == Direction.WEST) {
			x -= 2;
		} else if (dir == Direction.NORTH) {
			y += 2;
		} else { // Direction.SOUTH
			y -= 2;
		}

		if (x < 0 || x >= cells.size()) {
			return null;
		}
		if (y < 0 || y >= cells.get(0).size()) {
			return null;
		}

		return cells.get(x).get(y);
	}

	/**
	 * Generates a Hashiwokakero level which fills a given percentage of the grid
	 * with nodes. The level is generated by first placing a random node on the
	 * grid, then randomly extending the current graph until all nodes are created.
	 * 
	 * @param width
	 *            The width of the generated grid.
	 * @param height
	 *            The height of the generated grid.
	 * @param gridUsage
	 *            Percentage of the grid cells to be filled with nodes. Can be at
	 *            most 0.25, must be at least 0.01.
	 * @return A list of nodes which constitute the level.
	 */
	public static ArrayList<GridNode> generateLevel(final int width, final int height, double gridUsage,
			double pOuterExtension) {
		// An outer link is a link that leads to creating a new node, an inner link
		// connects to already existing nodes.
		if (gridUsage > 0.25 || gridUsage < 0.01) {
			throw new IllegalArgumentException("gridUsage must lie between 0.01 and 0.25");
		}
		if (pOuterExtension < 0 || pOuterExtension > 1) {
			throw new IllegalArgumentException("pOuterExtension must lie strictly between 0 and 1");
		}

		int nodesToPlace = (int) Math.round(width * height * gridUsage);
		if (nodesToPlace < 2) {
			nodesToPlace = 2; // minimum number of nodes to be placed
		}

		ArrayList<ArrayList<IncompleteNode>> cells = new ArrayList<ArrayList<IncompleteNode>>();
		for (int i = 0; i < width; ++i) {
			ArrayList<IncompleteNode> list = new ArrayList<IncompleteNode>();
			for (int j = 0; j < height; ++j) {
				list.add(null);
			}
			cells.add(list);
		}
		// List for easier creation of the final GridNode array.
		ArrayList<IncompleteNode> incompleteNodes = new ArrayList<IncompleteNode>();

		// Place the first node randomly on the grid.
		Random rand = new Random();
		int randX = rand.nextInt(width);
		int randY = rand.nextInt(height);
		IncompleteNode firstNode = new IncompleteNode(randX, randY);
		incompleteNodes.add(firstNode);
		cells.get(randX).set(randY, firstNode);
		nodesToPlace--;

		// Keep track of the possible extensions in each direction.
		// A node with two free pins into a direction will be added twice. A node with
		// only one free pin into a direction will be added once. This ensures that each
		// free pin has the same chance of being selected for extension.
		HashMap<Direction, ArrayList<IncompleteNode>> outerExtensions = new HashMap<Direction, ArrayList<IncompleteNode>>();
		// Each free pin leading to a direct neighbor counts as a possible inner
		// extension.
		HashMap<Direction, ArrayList<IncompleteNode>> innerExtensions = new HashMap<Direction, ArrayList<IncompleteNode>>();
		for (Direction dir : Direction.values()) {
			outerExtensions.put(dir, new ArrayList<IncompleteNode>());
			innerExtensions.put(dir, new ArrayList<IncompleteNode>());
		}

		for (Direction dir : Direction.values()) {
			if (firstNode.getPossible(dir, width, height) > 0) {
				outerExtensions.get(dir).add(firstNode);
			}
		}

		// Place the remaining nodes.
		// For nicer aesthetics of the finished level, no nodes can be placed directly
		// north, south, east, or west of a node.
		while (nodesToPlace > 0) {
			int totalOuterPossible = 0;
			for (Direction dir : Direction.values()) {
				totalOuterPossible += outerExtensions.get(dir).size();
			}
			int totalInnerPossible = 0;
			for (Direction dir : Direction.values()) {
				totalInnerPossible += innerExtensions.get(dir).size();
			}

			if (totalOuterPossible == 0) {
				// In very rare cases, there are no possible outer extensions left. In these
				// cases, we redo the whole generation.
				return generateLevel(width, height, gridUsage, pOuterExtension);
			}

			// randomly decide whether to do an inner extension or an outer extension
			boolean doOuterExtension = (rand.nextDouble() <= pOuterExtension);

			DirectionSelection select;
			if (!doOuterExtension && totalInnerPossible > 0) { // do inner extension
				select = nextDirection(innerExtensions);
			} else { // do outer extension anyway
				select = nextDirection(outerExtensions);
			}
			IncompleteNode actNode = select.node;
			// Compute the coordinates of the neighbor for extension.
			int newX = actNode.getX();
			int newY = actNode.getY();
			if (select.dir == Direction.EAST) {
				newX += 2;
			} else if (select.dir == Direction.WEST) {
				newX -= 2;
			} else if (select.dir == Direction.NORTH) {
				newY += 2;
			} else { // Direction.SOUTH
				newY -= 2;
			}
			IncompleteNode neighbor = cells.get(newX).get(newY);

			if (neighbor == null) { // Create a new node. This means we did an outer extension.
				neighbor = new IncompleteNode(newX, newY);
				incompleteNodes.add(neighbor);
				cells.get(newX).set(newY, neighbor);
				nodesToPlace--;

				actNode.increaseGoal(select.dir);
				neighbor.increaseGoal(Direction.reverseDirection(select.dir));

				outerExtensions.get(select.dir).remove(select.node); // since the outer extension has now been done.
				innerExtensions.get(select.dir).add(select.node); // since there is still one pin open towards the new
																	// neighbor

				// update the possible extensions for the new node
				for (Direction dir : Direction.values()) {
					int possible = neighbor.getPossible(dir, width, height);
					if (possible > 0) {
						if (getDirectNeighborAt(neighbor, dir, cells) != null) { // it is a possible inner extension
							for (int i = 0; i < possible; ++i) {
								innerExtensions.get(dir).add(neighbor);
							}
						} else { // it is a possible outer extension
							outerExtensions.get(dir).add(neighbor);
						}
					}
				}

				// update the possible extensions for other neighbors of the new neighbor
				for (Direction dir : Direction.values()) {
					IncompleteNode otherNode = getDirectNeighborAt(neighbor, dir, cells);
					if (otherNode != null && otherNode != actNode) {
						if (outerExtensions.get(Direction.reverseDirection(dir)).contains(otherNode)) {
							// the outer extension of that node is now an inner extension
							outerExtensions.get(Direction.reverseDirection(dir)).remove(otherNode);
							for (int i = 0; i < otherNode.getPossible(Direction.reverseDirection(dir), width,
									height); ++i) {
								innerExtensions.get(Direction.reverseDirection(dir)).add(otherNode);
							}
						}
					}
				}

			} else { // we did an inner extension
				actNode.increaseGoal(select.dir);
				neighbor.increaseGoal(Direction.reverseDirection(select.dir));
				innerExtensions.get(select.dir).remove(actNode);
				innerExtensions.get(Direction.reverseDirection(select.dir)).remove(neighbor);
			}
		}

		ArrayList<GridNode> nodes = new ArrayList<GridNode>();
		for (IncompleteNode inode : incompleteNodes) {
			nodes.add(new GridNode(inode.getX(), inode.getY(), inode.getTotalGoal()));
		}
		return nodes;
	}
}
